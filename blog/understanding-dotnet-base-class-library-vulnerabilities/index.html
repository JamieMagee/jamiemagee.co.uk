<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><link href=https://gmpg.org/xfn/11 rel=profile><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Understanding .NET Base Class Library Vulnerabilities &#183; Jamie Magee</title><link rel=preload href=/css/poole.css as=style><link rel=preload href=/css/hyde.css as=style><link rel=preload href=/css/poole-overrides.css as=style><link rel=preload href=/css/hyde-overrides.css as=style><link rel=preload href=/css/hyde-x.css as=style><link rel=preload href=/fonts/BerkeleyMono-Regular.woff2 as=font type=font/woff2 crossorigin><link rel=preload href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" as=style crossorigin><link rel=preload href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css as=style crossorigin><link rel=preload href=https://cdn.jsdelivr.net/npm/@justinribeiro/lite-youtube@1/lite-youtube.min.js as=script crossorigin><link rel=stylesheet href=/css/poole.css><link rel=stylesheet href=/css/hyde.css><link rel=stylesheet href=/css/poole-overrides.css><link rel=stylesheet href=/css/hyde-overrides.css><link rel=stylesheet href=/css/hyde-x.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" crossorigin><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css crossorigin><style>@font-face{font-family:berkeley mono;src:url(/fonts/BerkeleyMono-Regular.woff2)format('woff2');font-display:swap}.lite-youtube-fallback{aspect-ratio:16/9;display:flex;justify-content:center;align-items:center;flex-direction:column;gap:1em;padding:1em;background-color:#000;color:#fff;text-decoration:none;border-radius:8px;transition:background-color .2s ease}.lite-youtube-fallback:hover{background-color:#333;color:#fff}.lite-youtube-fallback::before{display:block;content:'';border:solid transparent;border-width:2em 0 2em 3em;border-left-color:red;transition:border-left-color .2s ease}.lite-youtube-fallback:hover::before{border-left-color:#fff}.lite-youtube-fallback:focus{outline:2px solid red;outline-offset:2px}</style><link rel=stylesheet href=/css/jamie.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel=icon type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><meta name=description content><meta name=keywords content><meta name=author content="Jamie Magee"><meta name=robots content="index, follow"><link rel=canonical href=/blog/understanding-dotnet-base-class-library-vulnerabilities/><meta property="og:url" content="/blog/understanding-dotnet-base-class-library-vulnerabilities/"><meta property="og:site_name" content="Jamie Magee"><meta property="og:title" content="Understanding .NET Base Class Library Vulnerabilities"><meta property="og:description" content="When you create a new .NET project and start writing code, you might find yourself using classes like System.Text.Json.JsonSerializer without ever explicitly adding a reference to System.Text.Json in your .csproj file. This isn’t magic—it’s because these Base Class Libraries (BCLs) are shipped as part of the .NET runtime itself, making them implicit references that are automatically available to your application.
But this convenience comes with a hidden security implication that many developers don’t realize: when a vulnerability is discovered in one of these implicit dependencies, patching it isn’t as straightforward as updating a NuGet package reference."><meta property="og:locale" content="en_gb"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-07-17T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-17T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding .NET Base Class Library Vulnerabilities"><meta name=twitter:description content="When you create a new .NET project and start writing code, you might find yourself using classes like System.Text.Json.JsonSerializer without ever explicitly adding a reference to System.Text.Json in your .csproj file. This isn’t magic—it’s because these Base Class Libraries (BCLs) are shipped as part of the .NET runtime itself, making them implicit references that are automatically available to your application.
But this convenience comes with a hidden security implication that many developers don’t realize: when a vulnerability is discovered in one of these implicit dependencies, patching it isn’t as straightforward as updating a NuGet package reference."><script type=module src=https://cdn.jsdelivr.net/npm/@justinribeiro/lite-youtube@1/lite-youtube.min.js></script></head><body class=theme-base-0c><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><div class=sidebar-head><h1><a href=/>Jamie Magee</a></h1></div><p class=lead>Programmer, Engineer, Problem Solver</p></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=/>Home</a></li><li class=sidebar-nav-item><a href=/about>About</a></li><li class=sidebar-nav-item><a href=/blog>Archive</a></li></ul><ul class=sidebar-nav><li class=sidebar-nav-item><a href=https://github.com/JamieMagee><i class="fa-brands fa-github-square fa-3x"></i></a>
<a href=https://bsky.app/profile/jamiemagee.bsky.social><i class="fa-brands fa-square-bluesky fa-3x"></i></a>
<a href=https://www.linkedin.com/in/jamiemagee1/><i class="fa-brands fa-linkedin fa-3x"></i></a>
<a href=/index.xml type=application/rss+xml><i class="fa-solid fa-rss-square fa-3x"></i></a></li></ul><p>&copy; 2025. <a href=https://creativecommons.org/licenses/by-nc/4.0/>CC BY-NC 4.0</a></p></div></div><div class="content container"><div class=post><h1 class=post-title>Understanding .NET Base Class Library Vulnerabilities</h1><span class=post-date>Jul 17, 2025 &#183; 5 minute read</span><p>When you create a new .NET project and start writing code, you might find yourself using classes like <code>System.Text.Json.JsonSerializer</code> without ever explicitly adding a reference to <code>System.Text.Json</code> in your <code>.csproj</code> file. This isn&rsquo;t magic—it&rsquo;s because these Base Class Libraries (BCLs) are shipped as part of the .NET runtime itself, making them implicit references that are automatically available to your application.</p><p>But this convenience comes with a hidden security implication that many developers don&rsquo;t realize: when a vulnerability is discovered in one of these implicit dependencies, patching it isn&rsquo;t as straightforward as updating a NuGet package reference.</p><h2 id=the-invisible-dependency-problem>The invisible dependency problem</h2><p>Let&rsquo;s start with a real-world example. In October 2024, Microsoft disclosed <a href=https://github.com/advisories/GHSA-8g4q-xg66-9fp4>CVE-2024-43485</a>, a high-severity denial of service vulnerability in <code>System.Text.Json</code>. The vulnerability affects applications that deserialize input to a model with a <code>[JsonExtensionData]</code> property.</p><p>Here&rsquo;s the catch: if you look at your <code>.csproj</code> file, you probably won&rsquo;t see any explicit reference to <code>System.Text.Json</code>. Yet your application might still be vulnerable. This is because <code>System.Text.Json</code> is part of the .NET runtime&rsquo;s Base Class Library, making it an implicit dependency that&rsquo;s automatically available to all .NET applications.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#0550ae>&lt;Project</span> <span style=color:#1f2328>Sdk=</span><span style=color:#0a3069>&#34;Microsoft.NET.Sdk&#34;</span><span style=color:#0550ae>&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>  <span style=color:#0550ae>&lt;PropertyGroup&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#0550ae>&lt;TargetFramework&gt;</span>net8.0<span style=color:#0550ae>&lt;/TargetFramework&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>  <span style=color:#0550ae>&lt;/PropertyGroup&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>  
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>  <span style=color:#57606a>&lt;!-- No explicit System.Text.Json reference, but you can still use it --&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span><span style=color:#0550ae>&lt;/Project&gt;</span>
</span></span></code></pre></div><h2 id=two-paths-to-patching>Two paths to patching</h2><p>When facing a vulnerability in an implicit dependency like this, you have two main options to ensure your application is secure:</p><h3 id=option-1-add-an-explicit-reference>Option 1: Add an explicit reference</h3><p>The most obvious solution is to add an explicit package reference to the vulnerable library:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#0550ae>&lt;Project</span> <span style=color:#1f2328>Sdk=</span><span style=color:#0a3069>&#34;Microsoft.NET.Sdk&#34;</span><span style=color:#0550ae>&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>  <span style=color:#0550ae>&lt;PropertyGroup&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#0550ae>&lt;TargetFramework&gt;</span>net8.0<span style=color:#0550ae>&lt;/TargetFramework&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>  <span style=color:#0550ae>&lt;/PropertyGroup&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>  
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>  <span style=color:#0550ae>&lt;PackageReference</span> <span style=color:#1f2328>Include=</span><span style=color:#0a3069>&#34;System.Text.Json&#34;</span> <span style=color:#1f2328>Version=</span><span style=color:#0a3069>&#34;8.0.5&#34;</span> <span style=color:#0550ae>/&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span><span style=color:#0550ae>&lt;/Project&gt;</span>
</span></span></code></pre></div><p>This approach leverages NuGet&rsquo;s <a href=https://learn.microsoft.com/en-us/nuget/concepts/dependency-resolution#direct-dependency-wins>&ldquo;direct dependency wins&rdquo;</a> rule. When your application has both an implicit dependency (from the runtime) and an explicit dependency (from your <code>.csproj</code>), the explicit one takes precedence, but only if the explicit version is equal to or higher than the BCL version in the runtime.</p><p>Here&rsquo;s the crucial detail: if you specify a lower version than what&rsquo;s bundled with the runtime, .NET will still use the runtime version. For example, if your runtime includes <code>System.Text.Json</code> version 8.0.4 and you explicitly reference version 8.0.2, the runtime version (8.0.4) will be used. This means you can&rsquo;t accidentally downgrade to a vulnerable version, but it also means your explicit reference must be at least as recent as the runtime version to take effect.</p><p>While this works, it&rsquo;s not a scalable long-term solution. The .NET runtime includes hundreds of libraries, and making all implicit references explicit would significantly clutter your project files and create a maintenance burden.</p><h3 id=option-2-set-a-minimum-sdk-version-with-globaljson>Option 2: Set a minimum SDK version with global.json</h3><p>A more sustainable approach is to use <code>global.json</code> to specify a minimum .NET SDK version that includes the patched libraries:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-json data-lang=json><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>  <span style=color:#0550ae>&#34;sdk&#34;</span><span style=color:#1f2328>:</span> <span style=color:#1f2328>{</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#0550ae>&#34;version&#34;</span><span style=color:#1f2328>:</span> <span style=color:#0a3069>&#34;8.0.110&#34;</span><span style=color:#1f2328>,</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    <span style=color:#0550ae>&#34;rollForward&#34;</span><span style=color:#1f2328>:</span> <span style=color:#0a3069>&#34;latestFeature&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>  <span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span><span style=color:#1f2328>}</span>
</span></span></code></pre></div><p>This ensures that anyone building your project—whether locally, in CI/CD, or when deploying—uses at least the specified SDK version, which includes the security patches for all Base Class Libraries.</p><h2 id=the-self-contained-deployment-consideration>The self-contained deployment consideration</h2><p>This distinction becomes even more critical if you&rsquo;re shipping <a href=https://learn.microsoft.com/en-us/dotnet/core/deploying/#publish-self-contained>self-contained applications</a>. When you publish a self-contained app, the .NET runtime is bundled with your application, including all the Base Class Libraries. If you build your self-contained app with an older SDK that contains vulnerable libraries, those vulnerabilities get shipped with your application.</p><p>For self-contained deployments, ensuring you&rsquo;re building with an up-to-date SDK isn&rsquo;t just about development convenience—it&rsquo;s a security requirement. A <code>global.json</code> file becomes essential for maintaining a security baseline across your entire deployment pipeline.</p><h2 id=the-current-developer-experience-pain>The current developer experience pain</h2><p>Currently, if you don&rsquo;t have the correct SDK version installed and try to build a project with a <code>global.json</code> requirement, you&rsquo;ll encounter an often inscrutable error message.</p><p>The good news is that the .NET team is aware of the problem. There&rsquo;s an ongoing effort tracked in <a href=https://github.com/dotnet/cli-lab/issues/390>dotnet/cli-lab#390</a> to create a .NET bootstrapper that will improve SDK acquisition and provide better error messages. This work aims to make .NET 10 much more user-friendly when dealing with SDK version mismatches.</p><h2 id=a-familiar-challenge-in-other-runtimes>A familiar challenge in other runtimes</h2><p>This pattern of implicit runtime dependencies isn&rsquo;t unique to .NET. Java developers face a remarkably similar challenge with the Java standard library. When a vulnerability is discovered in a core Java package like <code>java.util</code> or <code>java.security</code>, the remediation path typically involves updating the entire Java Runtime Environment (JRE) or Java Development Kit (JDK).</p><p>For example, when CVE-2022-21449 was discovered in Java&rsquo;s elliptic curve signature verification, applications using ECDSA signatures were vulnerable regardless of whether they explicitly imported the affected classes. The fix required updating to a patched version of the JRE.</p><p>However, Java&rsquo;s ecosystem has traditionally been more rigid in this regard. While .NET allows you to override BCL versions with explicit NuGet references (leveraging the &ldquo;direct dependency wins&rdquo; rule), Java applications are typically bound to whatever version of the standard library comes with their runtime. This makes the <code>global.json</code> approach even more critical in the .NET world, as it&rsquo;s often your most practical option.</p><p>The key difference is that .NET&rsquo;s package management system provides more flexibility—you can sometimes work around runtime library issues with explicit package references, whereas Java applications usually have no choice but to update their entire runtime environment.</p><h2 id=the-path-forward>The path forward</h2><p>The implicit nature of .NET&rsquo;s Base Class Libraries provides excellent developer productivity, but it also creates a unique security challenge. Unlike traditional NuGet dependencies that appear in your project file, BCL vulnerabilities require a different approach to remediation.</p><p>By understanding this distinction and adopting <code>global.json</code> as part of your security strategy, you can ensure your applications stay protected against vulnerabilities in both explicit and implicit dependencies. And with the improvements coming in .NET 10, this process should become much more seamless for developers.</p></div></div></body></html>